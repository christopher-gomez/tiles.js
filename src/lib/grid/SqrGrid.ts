import Engine, { EngineTileShapes } from '../Engine';
import { Vector3, Shape, BufferGeometry, ShapeGeometry, Geometry, MeshPhongMaterial, ExtrudeGeometry, Object3D, Line, ShapeBufferGeometry } from 'three';
import Grid from './Grid';
import { GridSettings, GridJSONData, MapSettings, heuristic, GridSettingsParams, MapSettingsParams } from '../utils/Interfaces';
import Cell from './Cell';
import Tile from '../map/Tile';
import SqrCell from './SqrCell';
import HexCell from './HexCell';
import HexTile from '../map/HexTile';
import SqrTile from '../map/SqrTile';
/*
  Graph of squares. Handles grid cell management (placement math for eg pathfinding, range, etc) and grid conversion math.
  Interface:
  type
  size - number of cells (in radius); only used if the map is generated
  cellSize
  cells - a hash so we can have sparse maps
  numCells
  extrudeSettings
  autogenerated
  cellShape
  cellGeo
  cellShapeGeo

  @author Corey Birnbaum https://github.com/vonWolfehaus/
 */
export default class SqrGrid extends Grid {
  constructor(config: GridSettingsParams) {
    let settings = {
      gridShape: Engine.GridShapes.SQUARE,
      gridRadius: 10,
      cellRadius: 10,
      cellShape: Engine.TileShapes.SQUARE,
    } as GridSettings;

    if (config)
      settings = Engine.Tools.merge(settings, config) as GridSettings

    if (settings.gridShape === Engine.GridShapes.FLAT_TOP_HEX) settings.gridShape = Engine.GridShapes.SQUARE;

    if (settings.cellShape !== Engine.TileShapes.SQUARE) settings.cellShape = EngineTileShapes.SQUARE;

    super(settings as GridSettingsParams);
  }
  /*
    ________________________________________________________________________
    High-leves that the map interfaces with (all grids implement)
   */

  cellToPixel(cell: Cell): Vector3 {
    this._vec3.x = cell.q * cell.perimeter;
    this._vec3.y = cell.h;
    this._vec3.z = cell.r * cell.perimeter;
    return this._vec3;
  }

  pixelToCell(pos: Vector3): Cell {
    const q = Math.round(pos.x / this._cel.perimeter);
    const r = Math.round(pos.z / this._cel.perimeter);
    return this._cel.set(q, r, 0);
  }

  getCellAt(pos: Vector3): Cell {
    const q = Math.round(pos.x / this._cel.perimeter);
    const r = Math.round(pos.z / this._cel.perimeter);
    this._cel.set(q, 0, r);
    return this.cells[this.cellToHash(this._cel)];
  }

  cellToHash(cell: Cell): string {
    return cell.q + this._hashDelimeter + cell.r; // s is not used in a square grid
  }

  distance(cellA: Cell, cellB: Cell): number {
    let d = Math.max(Math.abs(cellA.q - cellB.q), Math.abs(cellA.r - cellB.r));
    d += cellB.h - cellA.h; // include vertical size
    return d;
  }

  // create a flat, square-shaped grid
  generateGrid(config?: GridSettingsParams): void {
    super._setGridProps(config);
    // this._setCellWidthLengthAndFullSize();

    if (this.gridShape === Engine.GridShapes.RECT) {
      let x, y, c;
      const half = Math.ceil(this.gridRadius / 2);
      for (x = -half; x < this.gridRadius; x++) {
        for (y = -half; y < half; y++) {
          this.createCell(new Vector3(x, y, 0));
        }
      }
    } else {
      let x, y, c;
      const half = Math.ceil(this.gridRadius / 2);
      for (x = -half; x < half; x++) {
        for (y = -half; y < half; y++) {
          this.createCell(new Vector3(x, y, 0));
        }
      }
    }
  }

  public createCell(pos: Vector3, generateTile = false) {
    let c = new SqrCell(this.cellRadius, pos.x, pos.y + 1, 0, 0, this);
    this.add(c);

    if (generateTile) {
      const t = this.generateTile(c);

      const p = this.cellToPixel(c);
      p.y = 0;
      t.setPosition(p)

      return t;
    }
  }

  generateOverlay(size: number, overlayObj: Object3D, overlayMat: MeshPhongMaterial): void {
    let x, y;
    const geo = this.cellShape === Engine.TileShapes.HEX ? HexTile.baseTileShapePath.createPointsGeometry(6) : SqrTile.baseTileShapePath.createPointsGeometry(4);;
    const half = Math.ceil(size / 2);
    for (x = -half; x < half; x++) {
      for (y = -half; y < half; y++) {
        this._cel.set(x, y, undefined); // define the cell
        const line = new Line(geo, overlayMat);
        line.position.copy(this.cellToPixel(this._cel));
        line.rotation.x = 90 * Engine.DEG_TO_RAD;
        overlayObj.add(line);
      }
    }
  }

  generateNonPlayableTiles(size: number) {
    const tiles: Tile[] = [];

    return tiles;
  }

  dispose(): void {
    super.dispose();
  }
}