import Cell, { CellNeighborDirections } from "./Cell";
import { GridSettings, GridJSONData, GridSettingsParams, MapSettingsParams, TileJSONData } from "../utils/Interfaces";
import { Vector3, Object3D, Material } from "three";
import Tile from "../map/Tile";
import Engine, { EngineGridShapes, EngineTileShapes } from '../Engine';
import { heuristic } from '../utils/Interfaces';
import Tools from "../utils/Tools";
import HexCell from "./HexCell";
import SqrCell from "./SqrCell";
import Map from "../map/Map";

export default abstract class Grid {
  public config: GridSettings = {
    gridShape: Engine.GridShapes.FLAT_TOP_HEX,
    gridRadius: 10,
    cellRadius: 2,
    cellShape: Engine.TileShapes.HEX,
    isLoad: false
  };

  public static get TWO_THIRDS(): number { return 2 / 3 };

  // Interface
  protected _gridShape: EngineGridShapes;
  public get gridShape() {
    return this._gridShape;
  }
  protected _cellShape: EngineTileShapes;
  public get cellShape(): EngineTileShapes {
    return this._cellShape;
  }
  protected _gridRadius: number;
  public get gridRadius(): number {
    return this._gridRadius
  }
  protected _cellRadius: number;
  public get cellRadius(): number {
    return this._cellRadius;
  }
  protected _cells: { [key: string]: Cell };
  public get cells(): { [key: string]: Cell } {
    return this._cells;
  }
  protected _numCells: number;
  public get numCells(): number {
    return this._numCells;
  }
  protected _autoGenerated: boolean;
  public get autoGenerated(): boolean {
    return this._autoGenerated;
  }

  private _map: Map;
  public get map(): Map {
    return this._map;
  }

  // Internals
  protected _hashDelimeter: string;
  protected _list: Cell[];
  protected _vec3: Vector3;
  protected _cel: Cell;

  protected constructor(config?: GridSettingsParams) {
    this._init(config);
  }

  private _init(config?: GridSettingsParams) {
    this._setGridProps(config);

    // Generate cells
    this._cells = {};
    this._numCells = 0;

    // cached objects
    this._hashDelimeter = '.';
    this._list = [];
    this._vec3 = new Vector3();
    this._cel = this.cellShape === Engine.TileShapes.HEX ? new HexCell(this.cellRadius, 0, 0, 0, 0, this) : new SqrCell(this.cellRadius, 0, 0, 0, 0, this);
  }

  protected _setGridProps(config?: GridSettingsParams) {
    this.config = Tools.merge(this.config, config) as GridSettings;

    this._gridShape = this.config.gridShape;
    this._gridRadius = this.config.gridRadius;
    this._cellRadius = this.config.cellRadius;
    this._cellShape = this.config.cellShape;
  }

  abstract generateGrid(config: GridSettings): void;

  add(cell: Cell): Cell {
    const h = this.cellToHash(cell);
    if (this.cells[h]) {
      // console.warn('A cell already exists there');
      return;
    }
    this.cells[h] = cell;
    this._numCells++;

    return cell;
  }

  remove(cell: Cell): Cell {
    const h = this.cellToHash(cell);
    if (this.cells[h]) {
      delete this.cells[h];
      this._numCells--;
    }
    return cell;
  }

  abstract cellToHash(cell: Cell): string;
  abstract pixelToCell(pos: Vector3): Cell;
  abstract cellToPixel(cell: Cell): Vector3;
  abstract getCellAt(pos: Vector3): Cell;

  getNeighbors(cell: Cell, diagonals?: boolean, filter?: heuristic): Cell[] {
    // always returns an array
    let i, n;

    this._list.length = 0;

    for (i = 0; i < cell.directions.length; i++) {
      this._cel.copy(cell);
      this._cel.add(cell.directions[i]);
      n = this.cells[this.cellToHash(this._cel)];
      if (!n || (filter && !filter(cell, n))) {
        continue;
      }
      this._list.push(n);
    }

    if (diagonals) {
      for (i = 0; i < cell.diagonals.length; i++) {
        this._cel.copy(cell);
        this._cel.add(cell.diagonals[i]);
        n = this.cells[this.cellToHash(this._cel)];
        if (!n || (filter && !filter(cell, n))) {
          continue;
        }
        this._list.push(n);
      }
    }
    return this._list;
  }

  getNeighbor(cell: Cell, dir: CellNeighborDirections): Cell | null {

    let gridDir;
    if (!(dir.toString() in cell.neighborDirToGridDir)) return null;
    else gridDir = cell.neighborDirToGridDir[dir.toString()];

    let neighCell = cell.directions.find(x => x.gridPosition.equals(gridDir));

    if (!neighCell) neighCell = cell.diagonals.find(x => x.gridPosition.equals(gridDir));

    if (!neighCell) return null;

    this._cel.copy(cell);
    this._cel.add(neighCell);
    const n = this.cells[this.cellToHash(this._cel)];

    if (n) return n;

    return null;
  }

  getRandomCell(): Cell {
    let c;
    let i = 0;
    const x = Engine.Tools.randomInt(0, this.numCells);
    for (c in this.cells) {
      if (i === x) {
        return this.cells[c];
      }
      i++;
    }
    return this.cells[c];
  }

  dispose(): void {
    this._cells = null;
    this._numCells = 0;
    this._list = null;
    this._vec3 = null;

    HexCell.dispose();
    SqrCell.dispose();
  }

  protected generateTile(cell: Cell, scale: number, data?: TileJSONData
  ): Tile {

    const tile = cell.createTile(scale, this);

    if(data) tile.fromJSON(data);
    
    return tile;
  }

  generateTiles(map: Map, tilemapSettings?: MapSettingsParams): Tile[] {
    tilemapSettings = tilemapSettings || {} as MapSettingsParams;
    this._map = map;
    const tiles = [];

    // this._autoGenerated = true;
    // this._extrudeSettings = settings.extrudeSettings;

    let i, t: Tile, c: Cell;
    let index = 0;
    for (i in this.cells) {
      c = this.cells[i];
      t = this.generateTile(c, tilemapSettings && tilemapSettings.tileScale !== undefined ? tilemapSettings.tileScale : 1);
      
      const p = this.cellToPixel(c);
      p.y = 0;
      t.setPosition(p)

      if (this.config.isLoad && this.config.gridJSON && i in this.config.gridJSON.cells) {
        t.fromJSON(this.config.gridJSON.cells[i].tileData);
      }

      if (tilemapSettings && tilemapSettings.onTileCreated) tilemapSettings.onTileCreated(t, index);
      tiles.push(t);
      index++;
    }
    return tiles;
  }

  abstract generateOverlay(size: number, overlayObj: Object3D, overlayMat: Material): void;
  abstract distance(cellA: Cell, cellB: Cell): number;

  traverse(cb: (cell: Cell) => void): void {
    let i;
    for (i in this.cells) {
      cb(this.cells[i]);
    }
  }

  clearPath(): void {
    let i, c;
    for (i in this.cells) {
      c = this.cells[i];
      c.resetPath();
    }

    // let i, c;
    // for (i in this.cells) {
    //   c = this.cells[i];
    //   c._calcCost = 0;
    //   c._priority = 0;
    //   c._parent = null;
    //   c._visited = false;
    // }
  }

  /*
  Load a grid from a parsed json object.
  json = {
    extrudeSettings,
    size,
    cellSize,
    autogenerated,
    cells: [],
    materials: [
      {
        cache_id: 0,
        type: 'MeshLambertMaterial',
        color, ambient, emissive, reflectivity, refractionRatio, wrapAround,
        imgURL: url
      }
      {
        cacheId: 1, ...
      }
      ...
    ]
  }
*/
  load(url: string, callback: Function, scope: any): void {
    const self = this;
    Engine.Tools.getJSON({
      url: url,
      callback: function (json: GridJSONData) {
        self.fromJSON(json);
        callback.call(scope || null, json);
      },
      cache: false,
      scope: self
    });
  }

  fromJSON(json: GridJSONData): void {
    const cells = json.cells;

    this._cells = {};
    this._numCells = 0;

    let config: GridSettingsParams = {
      gridShape: json.gridShape,
      gridRadius: json.gridRadius,
      cellRadius: json.cellRadius,
      cellShape: json.cellShape,
      isLoad: true,
      gridJSON: json
    };

    this._setGridProps(config);

    // this._extrudeSettings = json.extrudeSettings;
    // this._autoGenerated = json.autoGenerated;

    // this.gridRadius = json.gridRadius;
    // this.cellRadius = json.cellSize;
    // this._setCellWidthLengthAndFullSize();

    for (let i in json.cells) {
      let cData = json.cells[i]
      let c = this.cellShape === Engine.TileShapes.HEX ? new HexCell(this.cellRadius, cData.q, cData.r, cData.s, cData.h, this) : new SqrCell(this.cellRadius, cData.q, cData.r, cData.s, cData.h, this);
      this.add(c);
    }
  }

  toJSON(): GridJSONData {
    const json: GridJSONData = {
      gridRadius: this.gridRadius,
      cellRadius: this.config.cellRadius,
      // extrudeSettings: this.extrudeSettings,
      // autoGenerated: this.autoGenerated,
      cells: {},
      gridShape: this.gridShape,
      cellShape: this.cellShape
    };

    if (this.cells) {
      Object.keys(this.cells).forEach(c => { json.cells[c] = this.cells[c].toJSON(); });
    }

    return json;
  }

  // protected abstract _createBaseCellShape();

  // protected abstract _setCellDirections();

  // protected abstract _setCellWidthLengthAndFullSize();

  public static dispose() {
    HexCell.dispose();
    SqrCell.dispose();
  }
}